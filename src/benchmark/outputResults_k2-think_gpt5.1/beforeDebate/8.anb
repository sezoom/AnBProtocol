The four-step asymmetric-key authentication protocol between A and B achieves the stated weak authentication goals through specific cryptographic operations and message exchanges. Here's the breakdown:

### **Goal 1: B Weakly Authenticates A on (A, M)**  
- **Step 1**: A sends a message \( M \) signed with its private key (\( \{M\}_{\text{sk}(A)} \)). B verifies this signature using A’s public key (\( \text{pub}(A) \)). Since only A holds the private key corresponding to \( \text{pub}(A) \), successful verification confirms that \( M \) originated from A and is unaltered. This weakly authenticates A to B because it validates A’s identity as the source of \( M \) without requiring freshness (non-injective).  

### **Goal 2: A Weakly Authenticates B on (B, N)**  
- **Step 2**: B sends its identity (\( B \)), public key (\( \text{pub}(B) \)), and a signed nonce \( N \) (\( \{N\}_{\text{sk}(B)} \)). A verifies the signature on \( N \) using \( \text{pub}(B) \) (assuming \( \text{pub}(B) \) is pre-trusted for identity \( B \)). Successful verification confirms that \( N \) was signed by B, authenticating B’s identity as the source of the message containing \( B \) and \( N \). This weakly authenticates B to A (non-injective), as it validates B’s identity without strictly preventing nonce reuse (though freshness is intended via \( N \)).  

### **Additional Protocol Contributions**  
- **Freshness (Nonce N)**: The nonce \( N \) in Step 2 is signed by B, ensuring it is newly generated for the session. Step 3 requires A to encrypt \( N \) (and its public key) with \( \text{pub}(B) \), which B decrypts and checks against the original \( N \). This prevents replay of outdated messages, enhancing session freshness but not directly affecting weak authentication.  
- **Mutual Key Knowledge (Step 3)**: A encrypting \( N \) and \( \text{pub}(A) \) with \( \text{pub}(B) \) confirms A’s knowledge of \( \text{pub}(B) \), while B decrypting it confirms its own knowledge of \( \text{sk}(B) \). This mutual confirmation of public keys supports session integrity.  
- **Shared Context (Step 4)**: B sends \( h(M, B, N) \), a hash of \( M \), \( B \), and \( N \). A recomputes the hash and verifies it matches B’s transmission. This binds all session data, ensuring both parties agree on the same message history and context, though it does not directly authenticate either party.  

### **Conclusion**  
The protocol fulfills its weak authentication goals:  
- **B authenticates A** via Step 1’s signature on \( M \), confirming A’s identity and \( M \)’s integrity.  
- **A authenticates B** via Step 2’s signed nonce \( N \), confirming B’s identity and \( N \)’s origin.  

Steps 3 and 4 reinforce freshness and shared context but are not required for the core authentication objectives.  

**Answer:** The protocol achieves B's weak authentication of A (Goal 1) through Step 1, where A signs message M with its private key, allowing B to verify A's identity using A's public key. For A's weak authentication of B (Goal 2), Step 2 enables A to verify B's signed nonce N using B's public key, confirming B's identity. Steps 3 and 4 ensure freshness and shared context but are secondary to the authentication goals. Thus, both weak authentication objectives are met via the signature operations in Steps 1 and 2.