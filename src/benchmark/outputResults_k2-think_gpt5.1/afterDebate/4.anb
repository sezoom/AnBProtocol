Protocol Four:

Declarations:
    aenc/2;       % Asymmetric encryption/signature function (assumed to be signature here per feedback)
    senc/2;       % Symmetric encryption function
    g/0;          % Group generator function (nullary)
    pk/1;         % Public key mapping (unary)
    sk/1;         % Private key mapping (unary)
    ChanK/2;      % Session key (binary) derived
    mul/2;        % Multiplication function (binary)
    exp/2;        % Exponentiation function (binary)

Types:
    Agent A,B;    % Agent type
    Number x,y,N1,N2;  % Number type for exponents and nonces
    Function g, mul, exp;  % Function symbols with declared arities
    Mapping pk, sk;        % pk and sk are mappings (public/private key functions) with arity 1
    Symmetric_key ChanK;  % ChanK is a symmetric key mapping (session key) with arity 2

Knowledge:
    A : pk(A), sk(A), pk(B);  % A knows its own public/private keys and B's public key
    B : pk(B), sk(B), pk(A);  % B knows its own public/private keys and A's public key

Public:
    pk(A), pk(B);  % Public keys are publicly known

Private:
    sk(A), sk(B), ChanK(A,B);  % Private keys and session key are secret

Actions:
    [m1] A -> B (x, N1) : aenc{ A . exp(g(), x) . N1 } sk(A);  % A sends fresh x, N1; signs with sk(A)
    [m2] B -> A (y, N2) : aenc{ B . exp(g(), y) . senc{ N1 } ChanK(A,B) . N2 } sk(B);  % B sends fresh y, N2; signs with sk(B), includes encrypted N1 under ChanK(A,B)
    [m3] A -> B         : senc{ N2 } ChanK(A,B);  % A confirms N2 under session key ChanK(A,B)

Goals:
    /* A authenticates to B via m1 (B verifies signature with pk(A)) */
    A -> B : A . exp(g(), x) . N1;
    /* B authenticates to A via m2 (A verifies signature with pk(B)) */
    B -> A : B . exp(g(), y) . senc{ N1 } ChanK(A,B) . N2;
    /* Secrecy of session key ChanK(A,B) */
    ChanK(A,B) secret between A,B;

ChannelKeys:
    ChanK(A,B): exp(g(), mul(x,y));  % Session key derived as g^(x*y) using declared functions

end