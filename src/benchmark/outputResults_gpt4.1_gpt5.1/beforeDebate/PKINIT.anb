```text
Protocol PKINIT:

Declarations:
    aenc/2;
    senc/2;
    sign/2;
    hash/1;
    kdf/3;
    prf/3;
    octetstring2key/1;
    random-to-key/1;
    DH/2;
    pk/1;
    sk/1;

Types:
    Agent A,B,S;
    Number NA, NB, n, ctime, cusec, Sid, tagPKINIT1, tagPKINIT2, tagPKINIT3, clientDHNonce, serverDHNonce, dhKeyExpiration;
    Symmetric_key K_AS, K_TGT, K_tmp;
    Function hash, kdf, prf, octetstring2key, random-to-key, DH;
    Mapping pk, sk;

Knowledge:
    A : pk(A), sk(A), pk(S), S;
    S : pk(S), sk(S), pk(A), A;
    B : pk(B), sk(B), pk(S), S;

Public:
    pk(A), pk(S), pk(B);

Private:
    sk(A), sk(S), sk(B);

Actions:
    /* AS Exchange: Initial Authentication with PKINIT (Diffie-Hellman variant) */

    [p1] A -> S (NA, ctime, cusec, n, clientDHNonce, ya) :
        aenc{ 
            A . S . NA . ctime . cusec . n . 
            sign{ 
                hash(AS_REQ_BODY) 
            }sk(A) . 
            ya . clientDHNonce . tagPKINIT1 
        }pk(S);

    /* S verifies signature, checks certificates, and generates DH key pair (yb, DHSharedSecret) */
    [p2] S -> A (NB, yb, serverDHNonce, dhKeyExpiration) :
        aenc{
            S . A . NB . yb . 
            sign{
                yb . n . dhKeyExpiration . tagPKINIT2
            }sk(S) . 
            serverDHNonce
        }pk(A);

    /* Both sides compute DHSharedSecret = DH(ya, sk(S)) = DH(yb, sk(A)), derive K_AS */
    /* K_AS = octetstring2key(DHSharedSecret | clientDHNonce | serverDHNonce) */

    /* S sends AS-REP encrypted with K_AS (session key for TGT) */
    [p3] S -> A (K_TGT) :
        senc{
            TGT . K_TGT . tagPKINIT3
        }K_AS;

    /* Optionally, S includes AD_INITIAL_VERIFIED_CAS in TGT */

    /* (Alternative: Public Key Encryption variant) */
    /* If A does not use DH, S generates random K_AS, encrypts with A's pk */
    [p2b] S -> A (K_tmp, K_AS) :
        aenc{
            senc{
                K_AS . hash(AS_REQ)
            }K_tmp
        }pk(A);

    /* S sends AS-REP encrypted with K_AS */
    [p3b] S -> A (K_TGT) :
        senc{
            TGT . K_TGT . tagPKINIT3
        }K_AS;

Goals:
    S -> A : K_AS;
    K_AS secret between A,S;
    S authenticates A on pk(A), signature, and possession of sk(A);
    A authenticates S on pk(S), signature, and possession of sk(S);

ChannelKeys:
    K(A,S): K_AS;
    K(S,A): K_AS;

end
```
**Notes:**
- `ya` and `yb` are the DH public keys of A and S, respectively.
- `clientDHNonce` and `serverDHNonce` are random nonces for key derivation.
- `K_AS` is the session key derived for encrypting the AS-REP (TGT).
- `K_TGT` is the ticket-granting ticket session key (delivered inside the AS-REP).
- `sign{...}sk(X)` denotes a signature by X.
- `aenc{...}pk(X)` denotes asymmetric encryption under X's public key.
- `senc{...}K` denotes symmetric encryption under key K.
- `octetstring2key(DHSharedSecret | clientDHNonce | serverDHNonce)` is the key derivation as per RFC 4556.
- The public key encryption variant is included as an alternative if DH is not used.
- All fresh values are declared in the message step where generated.
- Tags are included for binding and context as per Kerberos conventions.
- The protocol focuses on the initial authentication (AS exchange) with PKINIT.
