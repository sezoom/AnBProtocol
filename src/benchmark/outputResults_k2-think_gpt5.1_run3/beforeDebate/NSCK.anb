**Protocol NSCK (Alice, Bob, Trusted Server S)**  

**Objective:** Establish a bidirectional session key \( K_{AB} \) between Alice (A) and Bob (B), enabling mutual authentication with Bob non-injectively authenticating Alice on nonce \( N_B \) (expressed as \( B \rightarrow^* A : N_B \)), and ensuring confidentiality of subsequent traffic via \( K_{AB} \).  

**Long-term Keys:**  
- Alice and S share symmetric key \( sk_{AS} \) (used for secure Alice-S communication).  
- Bob and S share symmetric key \( sk_{BS} \) (used for secure Bob-S communication).  

**Session Key:** \( K_{AB} \) (fresh, generated by S; intended as secret bidirectional channel key for A and B).  

**Message Flow:**  

1. **Alice’s Key Request (m1):**  
   Alice → S: \( \text{tagnsck3} \parallel \text{Alice} \parallel \text{Bob} \parallel N_A \)  
   - \( N_A \): Alice’s fresh nonce (for freshness and request binding).  
   - Purpose: Initiate protocol; identify Alice as requester, Bob as peer.  

2. **Server’s Response with \( K_{AB} \) (m2):**  
   S generates \( K_{AB} \). S → Alice: \( \text{senc}\{\text{tagnsck6} \parallel N_A \parallel \text{Bob} \parallel K_{AB} \parallel \text{senc}\{\text{tagnsck4} \parallel K_{AB} \parallel \text{Alice}\}_{sk_{BS}}\}_{sk_{AS}} \)  
   - Components (after Alice decrypts with \( sk_{AS} \)):  
     - \( \text{tagnsck6} \): Protocol tag for m2.  
     - \( N_A \): Matches m1’s \( N_A \) to bind response to request.  
     - Bob’s identity, \( K_{AB} \).  
     - Inner ticket (encrypted with \( sk_{BS} \)): \( \text{senc}\{\text{tagnsck4} \parallel K_{AB} \parallel \text{Alice}\}_{sk_{BS}} \) (intended for Bob).  
   - Alice’s Processing: Decrypts m2 with \( sk_{AS} \), verifies \( N_A \) matches m1’s \( N_A \), accepts \( K_{AB} \).  

3. **Alice Forwards Ticket to Bob (m3):**  
   Alice → Bob: \( \text{senc}\{\text{tagnsck2} \parallel K_{AB} \parallel \text{Alice}\}_{sk_{BS}} \)  
   - Purpose: Forward S-generated ticket (encrypted under \( sk_{BS} \)) to Bob.  
   - Bob’s Processing: Decrypts with \( sk_{BS} \), retrieves \( K_{AB} \) and Alice’s identity, accepts \( K_{AB} \).  

4. **Bob’s Key Confirmation (m4):**  
   Bob generates fresh nonce \( N_B \). Bob → Alice: \( \text{senc}\{\text{tagnsck1} \parallel N_B\}_{K_{AB}} \)  
   - Purpose: Encrypt \( N_B \) under \( K_{AB} \) to prove Bob knows \( K_{AB} \); \( N_B \) enables freshness verification.  

5. **Alice’s Confirmation Response (m5):**  
   Alice decrypts m4 with \( K_{AB} \), retrieves \( N_B \). Alice → Bob: \( \text{senc}\{\text{tagnsck5} \parallel \text{pre}(\text{tagnsck7}, N_B)\}_{K_{AB}} \)  
   - Purpose: Encrypt \( \text{pre}(\text{tagnsck7}, N_B) \) under \( K_{AB} \) to confirm Alice knows \( K_{AB} \) and processed \( N_B \).  
   - Bob’s Verification: Decrypts with \( K_{AB} \), recomputes \( \text{pre}(\text{tagnsck7}, N_B) \), checks match. Success confirms Alice’s liveliness and shared \( K_{AB} \) (achieving \( B \rightarrow^* A : N_B \)).  

**Key Properties:**  
- \( K_{AB} \) remains secret to Alice, Bob, and S.  
- Tags (\( \text{tagnsck1}-\text{tagnsck7} \)) prevent message misinterpretation and role confusion.  
- Nonces \( N_A \) and \( N_B \) ensure freshness and resist replay attacks.  

This specification concisely outlines the five-message flow, cryptographic operations, and authentication/secrecy goals of NSCK.