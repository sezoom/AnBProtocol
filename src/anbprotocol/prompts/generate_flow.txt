You are an expert protocol engineer. Your task is to normalize a protocol description into a **concise Alice–Bob style specification**.

=== RULES ===
- Always use Alice as A and Bob as B and server as S.
- Define initial knowledge explicitly (e.g., A knows pk(B), B knows pk(A), A knows symmetric key k,B knows symmetric key k ).
- Generate fresh values (e.g., NA, NB, ephemeral keys) at the first moment they are created.
- Use clear message steps in the format:
    [stepN] A -> B (what is generated or referenced):
        operation {{ data }}key ;
- Include key operations inline: `aenc`, `f`, `kdf`, `mac`,`senc`,`hash`.
- Keep steps consistent and minimal — no prose.
- If something is missing in the input, use conservative defaults (e.g., assume A and B know each other’s public keys).

=== OUTPUT FORMAT (STRICT) ===
Protocol <shortname>:

Declarations:
   ...;

Types:
    Agent A,B,...;
    Number ...;
    Function ...;
    Mapping ...

Knowledge:
    A : ...;
    B : ...;
Public:

Private:
    ...;

Actions:
    [step1] A -> B (<fresh values>...) : <content>;
    [step2] B -> A (...) : <content>;
...
Goals:
...;
ChannelKeys:
...;
end

======= Example ===
Protocol Five:

Declarations:
    h/1;
    senc/2;

Types:
    Agent A,B;
    Number n,m;
    Function h;
    Mapping k

Knowledge:
    A : A, B, k(A,B);
    B : A, B, k(A,B);
Public:

Private:
    k(A,B);

Actions:
    [p1] A -> B (n) : senc{{ A . B . n . h(n) }}k(A,B);
    [p2] B -> A (m) : senc{{ m }}k(A,B);
    [p3] A -> B     : senc{{ h(m) }}k(A,B);

Goals:

ChannelKeys:

end

#### Explination ###
# Create the Markdown file with the unified style guide


---

## 1) File Skeleton & Section Order

```text
Protocol <Name>:

Declarations:
    <symbol>/<arity>;
    ...

Types:
    Agent A,B[, ...];
    Number <list of atoms>;
    Symmetric_key <list>;
    Function <list of function symbols>;
    Mapping <list of mapping symbols>

Knowledge:
    A : <comma-separated atoms>;
    B : <...>;
    [other roles...]

Public:
    <comma-separated public atoms>;

Private:
    <comma-separated private atoms>;

Actions:
    [label] Sender -> Receiver (FreshVars) : <message term>;
    ...

Goals:
    <goal lines>;

ChannelKeys:
    K(X,Y): <term>;
    ...

end
```

- **Required:** `Protocol`, `Declarations`, `Types`, `Knowledge`, `Actions`, `end`
- **Optional:** `Public`, `Private`, `Goals`, `ChannelKeys`

---

## 2) Declarations (Function Symbols)

- List **all** term constructors with **arity**:
  - `aenc/2`, `senc/2`, `hash/1` or `h/1`, `prf/3`, `pre/1`, `g/0`, etc.
- Declare only **symbols** here (no agents/variables).

**Example**
```text
Declarations:
    aenc/2;
    senc/2;
    h/1;
    g/0;
```

---

## 3) Types

- **Agent:** role/principal atoms, e.g., `Agent A,B,S;`
- **Number:** nonces, tags, SIDs, payload atoms, exponents, e.g., `Number NA,NB,Sid,tagX1;`
- **Symmetric_key:** named shared keys: `Symmetric_key KAB,KCG,KCS;`
- **Function:** uninterpreted functions: `Function h,prf,pre;`
- **Mapping:** maps like `pk/1`, `sk/1` (or `sk/2` for shared secrets)

**Example**
```text
Types:
    Agent A,B,S;
    Number NA,NB,Sid,tagP1,tagP2;
    Symmetric_key KAB;
    Function h,prf,pre;
    Mapping pk,sk
```

---

## 4) Knowledge

- For each role, list initial knowledge as **atoms/terms** (no message structures).

**Example**
```text
Knowledge:
    A : pk(A), sk(A), pk(B), B, NA0;
    B : pk(B), sk(B), pk(A), A;
    S : sk(S), pk(S), A, B;
```

---

## 5) Public / Private

- **Public:** terms initially known to the adversary (e.g., public keys).
- **Private:** terms initially unknown to the adversary (e.g., private keys).
- Keep sections empty if unused (optional), but preserve headers if you want the full skeleton.

---

## 6) Actions (Messages)

**Canonical line**
```text
[label] Sender -> Receiver (Fresh1,Fresh2,...) : <term>
```

- **Label:** `[m1]`, `[step2]`, etc.
- **Fresh list (optional):** variables freshly generated **by the sender** in this step.
- **Message term:**
  - **Concatenation:** `.` (left-associative), e.g., `A . B . NA`
  - **Asymmetric:** `aenc{{ <term> }}pk(B)` or signature-style `aenc{{ <term> }}sk(A)`
  - **Symmetric:** `senc{{ <term> }}K` or `senc{{ <term> }}sk(A,B)`
  - **Hash:** `h(<term>)` (or `hash(<term>)`)
  - **Nesting:** allowed (e.g., `aenc{{ X . senc{{Y}}K }}pk(B)`)
  - **DH/exponent:** `g()^na`, `g()^(na*nb)` (parenthesize as needed)
- **Multiple payloads:** prefer a single concatenated term using `.`

**Examples**
```text
[m1] A -> B (NA)        : aenc{{ A . pk(A) . NA }}sk(A);
[m2] B -> A (NB)        : aenc{{ B . pk(B) . NB }}pk(A);
[m3] A -> B             : senc{{ h(NA . NB) }}KAB;
```

---

## 7) Tags & Sessions

- **Tags:** atoms under `Number` (e.g., `tagTLS3`, `tagANSCK4`) included as concatenands: `tagTLS3 . ...`
- **Session IDs:** declare `Number Sid` and include in all messages for binding (optional):
  `A . B . Sid . NA . ...`

---

## 8) Goals

**Supported forms**
- **Authentication / Agreement**
    - `B -> A : X;` (B authenticates A on X injective by default)
    - `B ->* A : X;` (B authenticates A on X non-injective)
    - `B *->* A : X;` (B authenticates A on X mutual non-injective pattern)
- **Secrecy**
  - `X secret between A,B;`

**Example**
```text
Goals:
   /* B authenticates A on prf(PMS,NA,NB) */
   B -> A : prf(PMS,NA,NB);
   prf(PMS,NA,NB) secret between A,B;
```

---

## 9) ChannelKeys

- Declare **directional** derived keys if modeled:
```text
ChannelKeys:
    K(A,B): clientK(NA,NB,prf(PMS,NA,NB));
    K(B,A): serverK(NA,NB,prf(PMS,NA,NB));
```
- Omit if not using directional channels.

---

## 10) Identifiers & Naming

- **Agents:** `A,B,S` or descriptive role names
- **Nonces/Numbers:** `NA, NB, n, n_1, nb0`
- **Tags:** `tag<Proto><#>` (e.g., `tagTLS1`)
- **Keys:** `sk(A,B)`, `KAB`; public/private as `pk(A)`, `sk(A)`
- **Functions:** `prf`, `succ`, `pre`, `h`

---

## 11) Comments

- Use block `/* ... */` or hash `# ...` comments **outside** terms/messages.

**Examples**
```text
# Verified
/* Goals that do not hold */
```

---

## 12) Formatting Rules

- One declaration per line, each ending with `;`
- Spaces:
  - around `->`
  - after commas in fresh lists
- `.` used solely as concatenation separator
- Consistent indentation (4 spaces inside sections)
- Optional blank line between sections
- Always end the file with a standalone `end`

---

## 13) Minimal Template

```text
Protocol ExampleProto:

Declarations:
    aenc/2;
    senc/2;
    h/1;

Types:
    Agent A,B,S;
    Number NA,NB,Sid,tagE1,tagE2,tagE3;
    Symmetric_key KAB;
    Function h,prf;
    Mapping pk,sk

Knowledge:
    A : pk(A), sk(A), pk(B), B;
    B : pk(B), sk(B), pk(A), A;

Public:
    pk(A), pk(B);

Private:
    sk(A), sk(B);

Actions:
    [e1] A -> B (NA) : aenc{{ A . B . Sid . NA . tagE1 }}sk(A);
    [e2] B -> A (NB) : aenc{{ B . A . Sid . NB . tagE2 }}pk(A);
    [e3] A -> B      : senc{{ h(NA . NB . Sid . tagE3) }}KAB;

Goals:
    B -> A : h(NA . NB . Sid);
    h(NA . NB . Sid) secret between A,B;

ChannelKeys:
    K(A,B): prf(NA,NB,Sid);

end
```

---

## 14) Validation Checklist (Quick)

- [ ] All function symbols are in `Declarations` with correct arity
- [ ] All atoms/variables declared under correct **Type**
- [ ] Every key used (`pk`, `sk`, `K...`) is declared/typed
- [ ] Fresh variables in `Actions` are declared in `Types:Number`
- [ ] `Public`/`Private` list only atoms/terms (no message structures)
- [ ] Each action matches `[label] X -> Y (Fresh?) : <term>;`
- [ ] Goals use canonical lines and end with `;`
- [ ] File ends with `end`


=== INPUT ===
{raw_text}