Protocol Basic_Kerberos specifies a classic ticket-based symmetric key establishment and mutual authentication mechanism between a client A and a server B, mediated by a trusted key distribution center S. The long-term symmetric key kAS is shared between A and S, and the long-term symmetric key kBS is shared between B and S. These keys are used only to protect communication with S and are assumed to be known only to the respective pairs (A,S) and (B,S). A fresh session key kAB, generated by S, is intended to be shared between A and B and subsequently used as their bidirectional channel key. The protocol also uses a client-generated nonce nA, a ticket lifetime tL, and a client timestamp tA for freshness and replay protection. Symmetric encryption under a key K is denoted by senc{·}K.

The protocol begins when A requests a session key from S to communicate with B. In message m1, A sends A . B . nA to S. This message identifies the requesting principal (A), the intended communication partner (B), and includes a fresh nonce nA. The nonce nA enables A to later verify that any reply from S is linked to this particular request and is not a replay.

Upon receiving m1, S generates a fresh session key kAB for use between A and B, and selects a ticket lifetime tL. S then constructs message m2, which is encrypted under kAS as senc{ kAB . B . nA . tL . senc{ kAB . A . tL }kBS }kAS. The outer encryption ensures that only A can read S’s response. Inside, S includes kAB, the identity of B, the original nonce nA, and the lifetime tL, thereby allowing A to confirm that the key is fresh, intended for B, and associated with its earlier request. In addition, S embeds a “ticket” for B: senc{ kAB . A . tL }kBS, which is encrypted under B’s long-term key kBS and is therefore readable only by B and S. This ticket binds the session key kAB to the client A and to the validity interval tL.

After decrypting m2 using kAS, A learns the session key kAB, verifies that the received nA matches its original nonce, and accepts kAB as the key for communicating securely with B. A then proceeds to contact B directly in message m3. This message consists of two components: the ticket for B, senc{ kAB . A . tL }kBS, and an authenticator senc{ A . tA }kAB, where tA is a timestamp freshly chosen by A. The ticket proves to B, once decrypted under kBS, that the key kAB was issued by S and is intended for communication with A for the duration tL. The authenticator proves to B that the party presenting the ticket not only has the ticket but also knows kAB, and that the message is fresh with respect to tA (assuming timely clocks and the validity interval implied by tL).

Upon receiving m3, B decrypts the ticket using kBS and recovers kAB, A’s identity, and tL. B then decrypts the authenticator under kAB, obtains A’s identity and timestamp tA, and checks that tA is within an acceptable range and consistent with the ticket’s lifetime. These checks assure B that it is communicating with the rightful holder of kAB and that the session is fresh. To provide mutual authentication, B sends message m4: senc{ tA }kAB. By returning the same timestamp tA, encrypted under kAB, B demonstrates to A that it has successfully derived kAB from the ticket and has correctly processed the authenticator.

At the conclusion of the protocol, both A and B share the session key kAB, which is used as the channel key in both directions, K(A,B) and K(B,A). The security goals express that A and B mutually authenticate each other on the tuple (A, B, kAB, tA), meaning each principal believes it is sharing kAB with the other, under the identities A and B, and with freshness tied to tA. Furthermore, kAB is required to remain secret between A, B, and S and not be disclosed to any other party.