This protocol provides mutual authentication and explicit key confirmation between two parties that already share a long-term symmetric key sk(A,B). It also delivers a fresh session key K from the initiator to the responder, while taking care not to expose the initiator’s nonce NA even if the session key is later compromised—hence the “NonReversible” name. The only cryptographic primitives are an authenticated-encryption scheme senc{·}(·) and a non-reversible function f(·,·) (instantiated as a preimage-resistant hash or a PRF). Multiple role- and field-specific tags are used for domain separation so that values can’t be reinterpreted across directions or protocols.

The run starts with a lightweight challenge from the responder: B sends its identifier and a fresh nonce NB under a tag that marks message 1. This gives the initiator a time-variant parameter and lets both sides agree on the transcript they’re talking about. The initiator then generates its own fresh nonce NA and a fresh session key K. It replies with its identifier and a single authenticated-encryption under sk(A,B) that packages (i) a message-2 tag, (ii) a bound transform of the responder’s challenge f(tag₆, NB), (iii) the initiator’s nonce NA, (iv) the initiator’s identifier A, and (v) the session key K. This ciphertext simultaneously authenticates A to B (only someone holding sk(A,B) could have created it), proves freshness by binding to NB via f(tag₆,·), and delivers K confidentially to B. Because the binding uses f(tag₆, NB) rather than echoing NB in the clear inside the protected payload, the structure resists simple cut-and-paste or cross-protocol confusions.

To finish, the responder confirms possession of K back to the initiator without revealing the initiator’s nonce: B sends an authenticated-encryption under K that contains a message-3 tag and the one-way image f(tag₇, NA). Successful decryption proves to A that B received and accepted K (explicit key confirmation), and that B learned the NA value protected under sk(A,B)—so B must also possess the long-term key. Crucially, even if K is later compromised, m3 does not leak NA itself; only f(tag₇, NA) is ever exposed under K. Thus the initiator’s nonce remains hidden from an attacker who learns only the session key after the fact.

From these flows, the guarantees are: to B, data-origin authentication of NA and acceptance of the fresh session key K as coming from A and bound to NB; to A, data-origin authentication of NB (it was the challenge that A bound into its response) and that B is live and holds K (via the K-encrypted return). The protocol achieves replay resistance through fresh nonces and the f(tag,·) bindings, prevents simple reflection and recontextualization through distinct tags per message and per f invocation, and provides confidentiality/integrity for all sensitive fields carried inside senc.
