Protocol NonReversible specifies a three-pass, symmetric-key–based mutual authentication and key establishment mechanism between agents A and B, using a previously shared long-term key skAB, a fresh session key K chosen by A, and a non-reversible function f. Both A and B know the shared key skAB and the function f, which is intended to behave as a one-way (non-invertible) function when applied to structured inputs consisting of protocol tags and nonces. The aim of the protocol is for A and B to authenticate each other’s freshness contributions (NA and NB) and to agree on a new session key K that is secret between them, while using distinct protocol tags to bind messages to roles, directions, and specific runs.

The protocol begins when B initiates the exchange in message m1 by choosing a fresh nonce NB and sending tagNonReversible1 . B . NB to A. This message contains a mechanism/tag identifier tagNonReversible1, B’s identity, and the challenge nonce NB. The tag distinguishes this message type from others and helps prevent confusion with different protocol steps or roles; NB serves as B’s freshness contribution and must be stored by B for later verification.

Upon receipt of m1, A generates its own fresh nonce NA and selects a new symmetric session key K to be established with B. In message m2, A sends
tagNonReversible2 . A . senc{ tagNonReversible3 . f{tagNonReversible6, NB} . NA . A . K }skAB
to B. The outer cleartext part (tagNonReversible2 . A) identifies the message type and the sender. The encrypted part, protected under the long-term key skAB, contains a second tag tagNonReversible3, the non-reversible function output f{tagNonReversible6, NB} applied to a structured input that includes the tag tagNonReversible6 and the nonce NB, followed by A’s fresh nonce NA, A’s identity, and the new key K. Because this payload is encrypted with skAB, only someone who shares skAB (intended to be B) can recover these values. The inclusion of f{tagNonReversible6, NB} links the response to the specific challenge NB received in m1, without revealing NB itself, while NA and K are bound to A and to this specific run through the tags and identities.

After decrypting m2 using skAB, B obtains f{tagNonReversible6, NB}, NA, A, and K. B recomputes f{tagNonReversible6, NB} from its stored NB and the known function f and checks that it matches the value inside the ciphertext. This confirms that the m2 ciphertext was generated in response to the challenge NB and by a party holding skAB. If the check succeeds, B accepts NA as A’s fresh contribution and K as the new session key for communication with A. To confirm possession of K and to provide data-origin authentication back to A, B sends message m3:
tagNonReversible4 . B . senc{ tagNonReversible5 . f{tagNonReversible7, NA} }K.
Here the encrypted part (now under the newly established key K) contains another tag tagNonReversible5 and the function value f{tagNonReversible7, NA}, computed over a structured input involving A’s nonce NA and a different tag tagNonReversible7. Using K as the encryption key demonstrates that B has successfully derived K from m2; using a non-reversible function of NA binds the response to A’s fresh nonce without exposing it directly. The outer tag tagNonReversible4 and the presence of B’s identity in clear tie the message to B and to this protocol step.

When A receives m3, it decrypts the ciphertext using K and recovers tagNonReversible5 . f{tagNonReversible7, NA}. A recomputes f{tagNonReversible7, NA} from its own nonce NA and verifies that the value matches. Because only a party knowing K could have produced a valid encryption under K, and only a party that previously learned NA could produce the correct function value, A concludes that B has successfully derived K and is participating in the same run, thereby completing mutual authentication. The use of different tags (tagNonReversible1–tagNonReversible7) in the function inputs and message structures helps prevent replay, reordering, or reflection of values across different steps or roles.

The intended security goals of Protocol NonReversible are that A non-injectively authenticates B on NA (A is assured that B has learned and responded to A’s fresh nonce), B non-injectively authenticates A on NB (via the function of NB inside the encrypted payload in m2), and that the newly established session key K remains secret between A and B. Although no explicit channel key is declared in the model, K is the key intended for subsequent secure communication once the protocol has successfully completed.