The TLS protocol  between two agents, A and B, with the help of a certification server S. Each agent X possesses a public key pk(X) and the corresponding private key sk(X). The server S acts as a certification authority and signs the bindings between an agent’s identity and its public key. A and B also use a pseudorandom function prf to derive symmetric channel keys from a pre-master secret PMS and two nonces NA and NB.

The protocol begins when A initiates a session with B by sending message m1. In this message, A transmits its fresh nonce NA, a session identifier Sid, and its proposed cryptographic parameters PA. These values are logically bound together with a protocol tag tagTLS1 and the identities of A and B, so that later verification can ensure that they belong to the same protocol run.

Upon receipt of m1, B responds with message m2. Here B sends its own fresh nonce NB and its cryptographic parameters PB, again including Sid and NA as received from A, and binding them with the tag tagTLS2. In addition, B sends a certificate of its public key, represented as aenc{ B . pk(B) }sk(S), which is the server S’s signature on the pair consisting of B’s identity and its public key. This allows A to authenticate pk(B) as belonging to B.

After verifying B’s certificate, A constructs message m3. First, A provides its own certificate aenc{ A . pk(A) }sk(S), allowing B to authenticate pk(A). Second, A generates a fresh pre-master secret PMS and sends it encrypted under B’s public key as aenc{PMS}pk(B), ensuring that only B can obtain PMS. Third, A signs a hash over NB, B’s identity, PMS, and the tag tagTLS3, sending aenc{ hash(NB . B . PMS . tagTLS3) }sk(A). This signature proves that the party knowing sk(A) is the one that selected PMS and is participating in this run with B’s nonce. Using the obtained PMS and the nonces NA and NB, A computes the key K(A,B) = prf(PMS, NA, NB) and sends a symmetric authentication value senc{ hash( A . B . Sid . NA . NB . PA . PB ) }K(A,B), which protects the transcript of the handshake so far.

Upon receiving m3, B verifies A’s certificate and signature, and decrypts PMS with sk(B). B then independently computes K(A,B) = prf(PMS, NA, NB), and also defines K(B,A) as the same PRF output, to be used for traffic in the reverse direction. To confirm key agreement and integrity of the entire handshake, B sends message m4, which consists of a symmetric authentication value senc{ hash( A . B . NA . NB . Sid . PA . PB . PMS . tagTLS4 ) }K(B,A). This value covers both parties’ identities, the nonces, the session identifier, all parameter choices, the pre-master secret, and the final protocol tag, thereby binding the derived key to this specific execution.

At the end of the exchange, both A and B have established a shared secret prf(PMS, NA, NB), which is used as the channel keys K(A,B) and K(B,A). The intended security goal is that B authenticates A on this derived value: B must be assured that the key was generated by a party that knows A’s private key and has participated in this protocol run with the given NA, NB, and Sid. Furthermore, prf(PMS, NA, NB) is required to remain secret between A and B and is not revealed to any other principal, including S.