Protocol ISO_onepass_CCF specifies a one-pass entity-authentication mechanism from a claimant A to a verifier B, based on a pre-shared symmetric key skAB and a cryptographic check function f. Both A and B know the shared key skAB; no other party is assumed to know it. The protocol does not establish new keys, nor provide mutual authentication; its purpose is to allow B to authenticate that A is currently active and to validate an application-specific field Text1 as originating from A and bound to this particular protocol run.

The protocol consists of a single message from A to B. In message m1, A sends a structured tuple containing: a protocol/tag identifier tagISO_onepass_CCF1; a freshly chosen nonce NA; the intended verifier’s identity B; an optional, unauthenticated field Text2; a cryptographic check value f(tagISO_onepass_CCF2, NA, B, Text1, skAB); and the cleartext value Text1. The function f is a keyed check function (e.g., a MAC) that takes as input at least the second tag tagISO_onepass_CCF2, the nonce NA, the verifier identifier B, the authenticated application data Text1, and the shared key skAB, and outputs an authentication value. The presence of both NA and B in the input binds the check value to this particular run and to this particular verifier, while Text1 is thereby authenticated as part of the protected context. The field Text2 is deliberately left outside the scope of the check and must not be relied upon for any security-critical decision; it may carry auxiliary or informational data only.

Upon receipt of m1, B processes the message using the shared key skAB. B extracts NA, B, Text1, and the received check value f(tagISO_onepass_CCF2, NA, B, Text1, skAB). B then recomputes the check function locally over the same structured input (including the appropriate tag and its own identifier B) and compares the result with the received value. If the values match, B accepts the message as having been generated by an entity that currently knows skAB and as authenticating the triple (NA, B, Text1). The freshness of NA (when combined with suitable replay protection at B) assures that the run corresponds to a recent action by A. The inclusion of B’s identity within the MAC input prevents the message from being safely reflected back to A or reused towards a different verifier.

The intended security goal of this mechanism, as expressed in the model, is that B non-injectively authenticates A on the data (NA, B, Text1), written as B ->* A : NA . B . Text1. That is, whenever B accepts a run of the protocol, there exists some run by A in which A sent a message under the shared key skAB with the same nonce, verifier identifier, and Text1. The protocol does not provide mutual authentication (from B to A), nor does it derive new channel keys; it purely provides one-pass data-origin authentication and aliveness of A for the authenticated application field Text1.
Reference:
ISO/IEC 9798-4:1999, Information technology — Security techniques — Entity authentication — Part 4: Mechanisms using a cryptographic check function.