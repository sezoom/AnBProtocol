Efficient and Timely Mutual Authentication
Dave Otway† and Owen Rees‡
The ANSA Project
24 Hills Road,
Cambridge CB2 1JP
United Kingdom
(ansa%alvey.uk@cs.ucl.ac.uk)

Abstract
This paper describes a protocol for efficient mutual authentication (via a mutually trusted third party) that assures both principal parties of the timeliness of the interaction without the use of clocks or double encipherment. The protocol requires a total of only four messages to be exchanged between the three parties concerned.

Introduction
This protocol is a development of the trusted third party, enciphered authentication protocols designed by Needham and Schroeder [1] and enhanced by Birrell [2]. It also eliminates the weakness pointed out by Denning and Sacco [3], whereby an intruder who discovers a conversation key can re-use the corresponding authenticator to initiate fraudulent conversations. Its development was prompted by an observation by Roger Needham that one of the basic principles of timely authentication was that “the suspicious party should always generate a challenge”. In mutual authentication, both parties are suspicious of each other and of the freshness of the authentication messages; therefore each must generate independent challenges in order to assure themselves of the timeliness of the interaction. Such a challenge must be returned, as part of the authenticator, enciphered in the private key of the challenging party. Its important property is that it has not previously been used to authenticate the two parties concerned. This property can be guaranteed either by storing all previously used challenges, by using numbers from a monotonically increasing sequence (e.g., time) or probabilistically by generating a sufficiently large number randomly.

Prior knowledge and beliefs
Before authentication can take place, each party must be in possession of the following information:
first party: P1 K1 P2
second party: P2 K2
authentication service: P1 K1 P2 K2
where Pn is the name of the principal to which the nth party is currently affiliated and Kn is the private key of Pn. Each party believes that private keys are known only to their corresponding principals and the trusted authentication service.

Protocol
A successful mutual authentication consists of the following sequence of messages (illustrated in figure 1), where {X}K means plaintext X enciphered in key K:
	1.	The first party sends the message C P1 P2 {R1 C P1 P2}K1 to the second party. C is both a conversation identifier and a common challenge generated by the first party and which must be enciphered by both parties. R1 is the first party’s specific challenge and {R1 C P1 P2}K1 is an enciphered request for the mutual authentication of P1 and P2. C must be in clear to allow the second party to encipher it. It may also be used to associate all the messages in the same authentication sequence and may be an identifier used in the underlying protocol layer. P1 P2 must be in clear to identify the principals to the other parties, in particular, the authentication service needs them to look up the corresponding private keys.
	2.	The second party generates its own specific challenge R2 and matching request {R2 C P1 P2}K2, including the common challenge C. It then sends the message C P1 P2 {R1 C P1 P2}K1 {R2 C P1 P2}K2 to the authentication service.
	3.	The authentication service looks up K1 and K2 using P1 and P2, then deciphers both requests and verifies that they form a matching pair (i.e., both contain C P1 P2). If so, it chooses a conversation key KC and returns the reply C {R1 KC}K1 {R2 KC}K2, containing a matching pair of enciphered authenticators, identified by C, to the second party.
	4.	The second party deciphers the second authenticator {R2 KC}K2 using its private key K2 to obtain its own challenge R2 and the conversation key KC, then forwards the reply C {R1 KC}K1, containing the first authenticator, identified by C, to the first party. The first party deciphers the first authenticator {R1 KC}K1 using its private key K1 to obtain its own challenge R1 and the conversation key KC.

Subsequent knowledge and beliefs
The authentication service is able to decipher both authentication requests {R1 C P1 P2}K1 and {R2 C P1 P2}K2 using the private keys of the alleged principals. If they match (i.e., both contain C P1 P2), then it knows that each was generated by some party which knew the private key of the corresponding principal and that both parties wished to converse with each other (because of P1 P2) at some coincident time (because of C). The authentication service does not know whether a malicious replay of the whole message has taken place; it simply issues information that is of no value to anyone but the two genuine parties.

When the second party has decoded its authenticator {R2 KC}K2 using its private key K2, it knows that if R2 matches its original challenge then the reply is timely and was generated by the authentication service. Because it trusts the authentication service only to issue a matching pair of authenticators if the original pair of requests were genuine and matched, it accepts P1 as the first party’s principal and KC as the secret conversation key.

When the first party has decoded its authenticator and verified R1 then it also knows the reply is timely and was generated by the authentication service. Because it has the same beliefs about the authentication service as the second party it accepts P2 as the second party’s principal and KC as the secret conversation key.

Because the first party chose the common challenge C, it knows that the second party’s request must have been timely for the authentication service to verify that the two requests matched, but the second party still has no assurance that the original request from the first party was not a replay. However, both parties should now be in possession of the secret conversation key KC, and the prompt receipt of a message correctly enciphered in KC assures the second party that the first party really is in possession of K1 and must therefore be affiliated to P1.

Discussion
The authentication requests and replies are symmetrical with respect to the two principals. This property enables either party to subsequently initiate a re-authentication and change of conversation key. The authentication reply messages are not re-usable because they would no longer be timely; therefore the full protocol must be used when restarting a conversation after one of the parties has discarded the conversation key. The small number of messages required makes this acceptable, especially since both parties are assured of the timeliness of the new authenticators and the new key. The authentication service is not obliged to keep state relating to active conversations and can therefore avoid the scaling problems that this would cause. However, it is able to detect and log fraudulently constructed requests. The first and last messages of this protocol can be piggy-backed onto the opening exchange of a connection-oriented conversation, as can the exchange of a cipher initialization vector. Known plaintext C P1 P2 being enciphered in the private keys K1, K2 is no longer a problem with modern stream ciphers, especially if it is always preceded by a random number.

Acknowledgment
We would like to thank Roger Needham for his helpful analysis and guidance.

References
	1.	Needham, R. M., and Schroeder, M. D. Using encryption for authentication in large networks of computers. Commun. ACM 21, 12 (Dec. 1978), 993–999.
	2.	Birrell, A. D. Secure communication using remote procedure calls. ACM Trans. Computer Systems 3, 1 (Feb. 1985), 1–14.
	3.	Denning, D. E., and Sacco, G. M. Timestamps in key distribution protocols. Commun. ACM 24, 8 (Aug. 1981), 533–536.

† Seconded from Marconi Instruments Ltd.
‡ Seconded from Racal Information Technology Developments Ltd.

 ￼