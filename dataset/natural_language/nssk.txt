Protocol nssk specifies the classic Needham–Schroeder symmetric-key protocol for key distribution and mutual authentication, involving two parties A and B and a trusted server S acting as a key distribution center (KDC). A and S share a long-term symmetric key kAS, and B and S share a long-term symmetric key kBS; these keys are used only for secure communication with S. The server S generates a fresh session key KAB, intended to be shared between A and B and then used as their bidirectional channel key. The protocol uses nonces Na and Nb for freshness, explicit tags (tagNSSK1–tagNSSK5) to bind values to specific steps, and a function f applied to Nb in the final step as a simple transformation used for key confirmation.

The protocol begins when A requests a session key to communicate with B. In message nssk1, A sends tagNSSK1 . A . B . Na to S, where Na is a fresh nonce chosen by A. This identifies the requester (A), the intended peer (B), and introduces a freshness value that A will later use to link S’s response to this request. Upon receiving this, S generates a fresh session key KAB and replies in nssk2 with
senc{ tagNSSK2 . Na . B . KAB . senc{ tagNSSK3 . KAB . A }kBS }kAS.
The outer encryption under kAS ensures that only A can read the response. Inside, S includes the original nonce Na, the identity B, the new session key KAB, and a “ticket” for B: senc{ tagNSSK3 . KAB . A }kBS, which is encrypted under kBS and is intended to be forwarded unchanged to B. After decrypting nssk2, A checks that the included Na matches its own nonce, thereby confirming that KAB is fresh and associated with this run, and learns the ticket for B.

In message nssk3, A forwards the ticket to B: senc{ tagNSSK3 . KAB . A }kBS. B decrypts this using kBS and recovers KAB and A’s identity, tagged as tagNSSK3. Since the ticket came from S under kBS, B accepts KAB as the session key for communication with A. To confirm key possession and provide a freshness test, B sends message nssk4 to A: senc{ tagNSSK4 . Nb }KAB, where Nb is a fresh nonce chosen by B. This proves to A that B has derived KAB and provides B’s challenge. Finally, A responds in nssk5 with senc{ tagNSSK5 . f(Nb) }KAB, applying the function f to Nb and encrypting the result under KAB. Successful decryption and verification that the value corresponds to f(Nb) assures B that A has received Nb and also holds KAB, completing mutual key confirmation.

The intended security goals are that B (non-injectively) authenticates A on the nonce Nb—expressed as B *->* A : Nb, meaning that whenever B accepts the run based on a correct f(Nb) under KAB, there exists a matching execution in which A processed Nb under the same session key—and that the session key KAB remains secret between A and B. Once the protocol completes, KAB is used as the channel key in both directions, K(A,B) and K(B,A), for subsequent secure communication.