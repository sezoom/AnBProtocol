Protocol SIGNED_DIFFIE_HELLMAN specifies an authenticated key exchange between two agents, A and B, based on an ephemeral Diffie–Hellman (DH) exchange combined with public-key signatures and a key-derivation function. Each agent X has a public–private key pair (pk(X), sk(X)). The public keys pk(A) and pk(B) and the DH generator g() are assumed to be known to all parties, while the private keys sk(A) and sk(B) remain secret. The parties derive a shared Diffie–Hellman value and feed it into a key derivation function kdf to obtain a symmetric session key DHkey, which is then used to encrypt signatures over the exchanged DH values. A hash function hash(·) is used to bind the DH values into the signatures. The symmetric encryption primitive senc{·}DHkey provides confidentiality and integrity of the signed data under the derived session key.

The protocol proceeds in three steps. In step 1, A chooses a fresh secret exponent x and sends the DH share g()^x to B. This value is public but, under the discrete logarithm assumption, does not reveal x. In step 2, B chooses its own fresh secret exponent y and replies with the DH share g()^y, followed by an encrypted signature. Both parties compute the same shared DH value: A will eventually compute (g()^y)^x, while B computes (g()^x)^y; these are equal and are input to the key derivation function kdf(·, "STS") to obtain DHkey. Using this DHkey, B constructs senc{ aenc{ hash(g()^y . g()^x) }sk(B) }DHkey and sends it along with g()^y. Inside the symmetric encryption is B’s signature (under sk(B)) on the hash of the ordered pair (g()^y, g()^x). Encrypting the signature under DHkey ensures that only someone who knows the DH-derived key—and thus has participated in the exchange—can see or reuse the signature.

Upon receiving step 2, A computes the shared Diffie–Hellman key (g()^y)^x and derives DHkey = kdf((g()^y)^x, "STS"). A then decrypts the symmetric part of B’s message with DHkey, recovers B’s signature, and verifies it using pk(B) against hash(g()^y . g()^x). A successful verification convinces A that the other party knows sk(B) and participated in the same DH exchange (using g()^y), thus authenticating B and binding B’s identity to the shared key. In step 3, A responds symmetrically by sending senc{ aenc{ hash(g()^x . g()^y) }sk(A) }DHkey to B. Here A signs the hash of the ordered pair (g()^x, g()^y) under sk(A) and encrypts this signature under the same DHkey. When B receives this message, it decrypts using its locally derived DHkey = kdf((g()^x)^y, "STS"), verifies the signature using pk(A), and checks that it matches hash(g()^x . g()^y). This assures B that A both knows the DH-derived key and possesses sk(A).

At the conclusion of the protocol, both A and B have computed the same symmetric key DHkey, designated as the bidirectional channel key K(A,B) and K(B,A), and each has verified a signature from the other party over the exchanged DH values. The goals state that B authenticates A and A authenticates B on hash(g()^x . g()^y), meaning that both parties agree on the DH transcript and its binding to the peers’ identities, and that DHkey remains secret between A and B. The protocol thus provides an authenticated Diffie–Hellman key exchange of the Station-to-Station (STS) style, with confidentiality of the signatures and mutual authentication of the established session key.