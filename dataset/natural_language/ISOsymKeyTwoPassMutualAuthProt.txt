Protocol ISO_twopass_mutual_symm specifies a two-pass mutual authentication mechanism between agents A and B, based on a pre-shared symmetric key skAB and structured, encrypted messages. Both parties know the shared key skAB and agree on two mechanism-specific tags tagITMS1 and tagITMS2, as well as a higher-level context identifier tag (e.g., for protocol suite or application binding). The protocol does not establish any new keys; its purpose is to allow A and B to mutually authenticate each other and to obtain data-origin authentication on application fields Text1 (from A) and Text3 (from B), with freshness guarantees provided by nonces NA and NB.

The protocol consists of two encrypted messages. In message m1, A initiates the exchange by selecting a fresh nonce NA and sending
senc{ tagITMS1 . NA . B . Text1 . tag }skAB to B. The ciphertext is computed under the shared key skAB over a structured tuple containing: the direction-specific tag tagITMS1, the fresh nonce NA, the intended peer identity B, the application data Text1 that A wishes to authenticate to B, and the context value tag. Because only A and B know skAB, successful decryption by B assures that the message originates from a party that holds this key. The inclusion of NA allows B to enforce freshness (e.g., via replay checks); the presence of B and tagITMS1 helps bind the message to the correct peer and protocol direction; and tag ties the run to the appropriate higher-level context.

Upon receipt of m1, B decrypts the message using skAB, recovers (tagITMS1, NA, B, Text1, tag), and verifies that the fields are well-formed, that the identity B matches itself, that tag and tagITMS1 correspond to the expected mechanism, and that NA is fresh according to its replay policy. If these checks succeed, B accepts Text1 as data-origin authentic from A in this run and is convinced that A currently knows skAB.

To provide reciprocal authentication, B responds with message m2. B chooses a fresh nonce NB and sends
senc{ tagITMS2 . NB . A . Text3 }skAB to A. This ciphertext is again computed under skAB, but now over a tuple containing tagITMS2 (the tag for the B→A direction), the fresh nonce NB, the intended peer identity A, and the application field Text3 that B wishes to authenticate to A. When A decrypts m2 using skAB, it obtains (tagITMS2, NB, A, Text3) and performs analogous checks: that A is itself, the tag is correct for this direction and protocol, and that NB is fresh. On success, A accepts Text3 as authentic data from B in this run and is assured of B’s possession of skAB.

The stated goals express these properties: B ->* A : Text3 means A non-injectively authenticates B on Text3—whenever A accepts Text3, there is a corresponding run in which B sent it under the shared key in this protocol; A ->* B : Text1 means B non-injectively authenticates A on Text1 under the same conditions. The protocol does not output or change any channel keys; it is purely a symmetric-key, two-pass mutual entity and data-origin authentication mechanism.Reference
	•	ISO/IEC 9798-2:2019, IT Security techniques — Entity authentication — Part 2: Mechanisms using authenticated encryption (scope, time-variant parameters, unilateral and mutual symmetric-key mechanisms).  ￼
	•	Basin, Cremers, Meier, “Provably Repairing the ISO/IEC 9798 Standard for Entity Authentication,” POST 2012 / JCS 2013 (analysis and recommended hardenings such as role-specific constants and identity binding).  ￼