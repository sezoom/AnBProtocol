Protocol ISO_twopass_mutual_CORR specifies a two-pass mutual authentication mechanism between agents A and B using public-key signatures and certificates issued by a trusted server S. Each principal X has a public–private key pair (pk(X), sk(X)). The public keys pk(A), pk(B), and pk(S) are assumed to be known to all parties, while the corresponding private keys remain secret to their owners. S acts as a certification authority that signs bindings between identities and public keys. The operator aenc{ · }sk(X) is used in signature mode (encryption with the private key, verifiable with pk(X)), providing integrity and origin authentication, but not confidentiality. Both A and B also know a shared context value tag, which ties the protocol run to a specific higher-level usage or configuration.

The protocol consists of two messages. In message m1, A initiates mutual authentication towards B. A sends two components. The first is aenc{ A . pk(A) }sk(S), which is S’s certificate on A, binding the identity A to its public key pk(A) under S’s private key. This allows B to verify, using pk(S), that pk(A) is an authentic public key for A. The second component is aenc{ tagisopubkeytwopmauth1 . NA . B . Text1 . tag }sk(A), a signature computed by A over a structured tuple containing a mechanism-specific tag tagisopubkeytwopmauth1, a fresh nonce NA, the intended peer’s identity B, an application field Text1 that A wants to authenticate to B, and the context value tag. By including B’s identity, the mechanism tag, and the context tag alongside the freshness value NA and Text1, A binds this data to the specific run, to B as verifier, and to the intended protocol/usage, helping to prevent reflection and cross-protocol attacks.

Upon receiving m1, B first verifies S’s certificate aenc{ A . pk(A) }sk(S) using pk(S) to recover and validate pk(A) as A’s public key. B then uses pk(A) to verify A’s signature on (tagisopubkeytwopmauth1, NA, B, Text1, tag). If the signature is valid and NA is accepted as fresh (e.g., not previously seen and within policy), B concludes that the message was generated by the holder of sk(A), that A is live in this run, and that Text1 is authentic and bound to A, B, and the current protocol context.

In message m2, B reciprocates in a symmetric fashion. B sends aenc{ B . pk(B) }sk(S), S’s certificate binding B to its public key pk(B), and aenc{ tagisopubkeytwopmauth2 . NB . A . Text2 }sk(B), a signature under sk(B) over the tuple (tagisopubkeytwopmauth2, NB, A, Text2). The mechanism-specific tag tagisopubkeytwopmauth2 distinguishes this direction of the protocol; NB is B’s fresh nonce; A is the intended peer; and Text2 is application data that B wishes to authenticate to A. On receipt, A verifies S’s certificate on B using pk(S) to obtain pk(B), then uses pk(B) to verify B’s signature. If the signature is valid and NB is fresh, A accepts Text2 as originating from B in this run.

The intended security properties, captured by the goals, are that B non-injectively authenticates A on Text1 (B ->* A : Text1) and A non-injectively authenticates B on Text2 (A ->* B : Text2). That is, whenever a party accepts the corresponding text as authentic, there exists a matching run of the peer who signed it under the shared trust of S’s certification. The protocol does not establish a new session key or channel key; it provides mutual, public-key–based entity and data-origin authentication for the application fields Text1 and Text2, with explicit binding to identities, nonces, and protocol tags.
Reference:
ISO/IEC 9798-3:2019, Information technology — Security techniques — Entity authentication — Part 3: Mechanisms using digital signature techniques (ten mechanisms; mutual authentication variants; object identifiers and role of a trusted third party).  ￼

Basin, Cremers, Meier. “Provably Repairing the ISO/IEC 9798 Standard for Entity Authentication,” POST 2012 / JCS 2013 (analysis and repairs, including domain-separating tags and identity binding to prevent reflection/UKS issues).  ￼