Protocol BilateralKeyExchange specifies a public-key–based authenticated key establishment between two agents, A and B, with A ultimately authenticating B on a freshly chosen symmetric key k. Each agent X has a public key pk(X) and a corresponding private key sk(X). The public keys pk(A) and pk(B) are assumed to be known to both parties and to the environment, while sk(A) and sk(B) remain private to their respective owners. A hash function h(·) is used to bind nonces into the messages for freshness and integrity. The session key k is a symmetric key that A creates and intends to share only with B, and it is later used as the bidirectional channel key K(A,B) and K(B,A).

The protocol is initiated by B. In message m1, B selects a fresh nonce nB and sends aenc{ nB . B }pk(A) to A. This value is encrypted under A’s public key, so only A can decrypt it and recover nB and B’s identity. The inclusion of B’s identity inside the encrypted payload helps A link the received nonce to the specific party B and prevents simple reflection or confusion with other principals.

Upon receiving m1, A decrypts the message using its private key sk(A), obtains nB, and generates its own fresh nonce nA as well as a new symmetric session key k. A then constructs message m2 as aenc{ h(nB) . nA . A . k }pk(B) and sends it to B. This message is encrypted under B’s public key, ensuring that only B can learn nA and k. The presence of h(nB) allows B to verify that the response is tied to the challenge nB sent in m1; the inclusion of A’s identity A binds the key k and nonces nB, nA explicitly to A as the initiator of the key choice. If B successfully decrypts m2 using sk(B) and finds that the first component matches h(nB), B accepts k as the session key for communication with A and records nA as A’s freshness contribution.

To provide key confirmation and authenticate itself to A as the holder of k, B sends message m3: senc{ h(nA) }k. This value is encrypted under k and contains the hash of A’s nonce nA. Since only a party that knows k can construct or decrypt this message, and since it depends on nA generated by A, a valid m3 demonstrates to A both that B has obtained k from m2 and that the message corresponds to the current protocol run. After receiving and decrypting m3 using k, A checks that the plaintext equals h(nA); if so, A concludes that B is indeed the peer that learned k from m2.

The intended security properties are that A (non-injectively) authenticates B on the session key k—written as A *->* B : k—meaning that whenever A completes the protocol believing it shares k with B, there is a corresponding run in which B has accepted the same key k. Additionally, the key k must remain secret between A and B and not be disclosed to any other party. Once the protocol completes successfully, k serves as the symmetric channel key in both directions, denoted K(A,B) and K(B,A).