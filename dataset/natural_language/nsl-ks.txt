
The protocol involves three roles: a key server that vouches for public keys, an initiator that starts the run, and a responder that completes it. Public-key operations use aenc{…}(·). When applied with the server’s private key, it yields a server-signed credential (a verifiable statement). When applied with a party’s public key, it yields encryption to that party. Every cryptographic structure is prefixed with a role-specific tag to keep purposes distinct and contexts separated.

The initiator first queries the key server for the responder’s current public key. The server replies with a signed credential naming the responder and carrying the responder’s public key. With this attested key in hand, the initiator generates a fresh challenge NA and sends it to the responder, encrypted under the responder’s public key and tagged for this leg; the ciphertext also carries the initiator’s identity so the challenge is unambiguously bound to its source.

The responder then performs its own lookup with the key server to obtain the initiator’s public key, and receives a corresponding server-signed credential. Using the attested key, the responder answers the initiator’s challenge and issues a new one: it samples a fresh NB and sends a ciphertext under the initiator’s public key that contains the echoed NA, the new NB, and the responder’s identifier, all under the appropriate tag. This both demonstrates receipt of the initiator’s challenge and binds the responder’s challenge to the same run.

To conclude, the initiator proves receipt of NB by returning a ciphertext under the responder’s public key that carries NB under its completion tag. At completion, the initiator has seen NA echoed back inside a message addressed to it, and the responder has received NB returned, each under the expected tags and keys. The key server’s signed responses provide authenticated discovery of the counterpart’s public key at the time of the run, and the tag structure keeps each cryptographic operation scoped to its precise purpose.