Protocol DenningSaccoPub specifies a public-key–based key establishment mechanism in which a trusted server S provides certified public keys for two agents, A and B, enabling A to set up a confidential session key kAB with B. Each principal X has a public key pk(X) and a corresponding private key sk(X). The public keys pk(A), pk(B), and pk(S) are assumed to be widely known, while the private keys sk(A), sk(B), and sk(S) remain secret to their respective owners. The operator aenc{·}sk(S) is used as a digital signature by S (encrypt-with-private-key, verifiable with pk(S)), whereas aenc{·}pk(X) is used as public-key encryption, providing confidentiality for X. The protocol also uses a timestamp or validity indicator tA, chosen by A, to support freshness. The session key kAB is a symmetric key to be shared between A and B and later used as the channel key.

The protocol begins when A contacts S to obtain certified public-key information. In message m1, A sends A.B to S, indicating that it (A) wishes to communicate with B and requires up-to-date certification material. On receipt of this request, S constructs message m2, which consists of two signed “certificates”: aenc{ A . pk(A) }sk(S) and aenc{ B . pk(B) }sk(S). Each of these binds an identity (A or B) to the corresponding public key, and the signature under sk(S) allows any party knowing pk(S) to verify that the binding was issued by S. A, upon receiving m2, can validate these signed structures and gain assurance about the authenticity of both its own public key and B’s public key, as certified by S.

Using this certification, A then initiates key establishment with B in message m3. A first forwards S’s signed certificates aenc{ A . pk(A) }sk(S) and aenc{ B . pk(B) }sk(S) so that B can verify the same identity–key bindings directly from S’s signatures. A then includes aenc{ aenc{ kAB . tA }sk(A) }pk(B). Internally, A signs the pair (kAB, tA) under its own private key sk(A), yielding aenc{ kAB . tA }sk(A), which asserts that A is the originator of this session key and timestamp. A then encrypts this signed blob under B’s public key pk(B), ensuring that only B can recover it. When B decrypts the outer aenc{ … }pk(B) using sk(B), it obtains A’s signature on (kAB, tA) and can verify this signature using pk(A) as certified by S. In this way, B learns the session key kAB, knows that it was chosen (or at least endorsed) by A, and sees that its validity is tied to the timestamp or lifetime tA.

At the end of the protocol, both A and B share the symmetric key kAB, which is designated as the channel key K(A,B) for subsequent secure communication. The intended security goals are that kAB remains secret between A and B and is not learned by any other principal, and that B non-injectively authenticates A on the key kAB (expressed as B ->* A : kAB), meaning that whenever B accepts a session key as coming from A through this protocol, there is a corresponding run in which A sent that key under the same structure. No explicit responder-to-initiator key confirmation message is modeled in this version; the focus is on authenticated, confidential delivery of kAB from A to B using S’s public-key certificates.