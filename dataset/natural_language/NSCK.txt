Protocol NSCK specifies a symmetric-key key-distribution and mutual-authentication mechanism between two parties A and B, assisted by a trusted server S acting as a key distribution center. A shares a long-term symmetric key skAS with S, and B shares a long-term symmetric key skBS with S. These long-term keys are used only for protecting communication with S. The server S generates a fresh session key KAB to be used between A and B as a bidirectional channel key. The protocol also uses nonces NA and NB, a function pre(·,·) applied to NB in the final step, and a series of explicit tags (tagnsck1–tagnsck7) to bind messages to particular roles and stages, preventing reflection or cross-protocol confusion. Symmetric encryption under a key K is denoted senc{…}K.

The protocol starts with A requesting a session key from S. In message m1, A sends
tagnsck3 . A . B . NA
to S, where NA is a fresh nonce chosen by A. This message identifies A as the requester, B as the intended peer, and carries a protocol-specific tag and freshness value NA that allows A later to verify that S’s reply is linked to this specific request.

Upon receiving m1, S generates a fresh session key KAB for use between A and B. S then constructs message m2 and sends it to A as
senc{ tagnsck6 . NA . B . KAB . senc{ tagnsck4 . KAB . A }skBS }skAS.
The outer encryption under skAS ensures that only A can read the response. Inside, S includes: the tag tagnsck6, the nonce NA to bind the reply to A’s request, the identity of B, the freshly generated key KAB, and an inner “ticket” for B of the form senc{ tagnsck4 . KAB . A }skBS. This ticket is encrypted under skBS and is therefore intended for B alone. On decrypting m2 with skAS, A verifies that the embedded NA matches the one it sent in m1, thus confirming freshness and that KAB is associated with the current run. A then accepts KAB as the new session key for communication with B.

In message m3, A forwards the ticket to B:
senc{ tagnsck2 . KAB . A }skBS.
This ticket reveals KAB and A’s identity to B once decrypted under skBS. Because only S and B know skBS, B can trust that this ticket originates from S and that the key KAB is intended for communication with A. After decrypting m3, B accepts KAB as the channel key for this session.

To provide key confirmation and prove possession of KAB, B then sends message m4 to A:
senc{ tagnsck1 . NB }KAB,
where NB is a fresh nonce chosen by B. This message is encrypted under the newly established session key KAB and contains a tag plus B’s nonce. Successful decryption by A demonstrates that A indeed knows KAB and allows A to learn NB as B’s freshness contribution.

Finally, in message m5, A responds by sending
senc{ tagnsck5 . pre(tagnsck7, NB) }KAB
to B. The payload is a tag combined with the output of the function pre(tagnsck7, NB), where pre is computed over NB and a distinct protocol tag tagnsck7. This value can be recomputed by B, who knows both NB and pre, and its correct appearance inside a ciphertext under KAB confirms to B that A has received NB and still possesses KAB. This final step provides B with explicit confirmation that A is live in the current run and has derived the same session key.

The stated goal of the protocol is that B non-injectively authenticates A on the nonce NB, expressed as B ->* A : NB. In other words, whenever B accepts the run based on the successful verification of m5, there exists a corresponding execution in which A processed NB under the same session key KAB. Additionally, KAB is used as the bidirectional channel key (K(A,B) and K(B,A)) and is intended to remain secret between A, B, and S, with confidentiality of subsequent traffic relying on its secrecy.