Protocol Kerberos_PKINIT specifies a public-key–based initialization and subsequent ticket-based key establishment flow between a client C and an application server s, using an authentication authority ath and an intermediate ticket-granting server g. The design follows the Kerberos architecture, but replaces the client’s long-term symmetric key with a public-key–based initial authentication (PKINIT-style). The client C and ath each possess public–private key pairs (pk(C), sk(C)) and (pk(ath), sk(ath)). The public keys pk(C) and pk(ath) are available to all parties, while their private keys remain secret. The authority ath and the ticket-granting server g share a symmetric key skag; the ticket-granting server g and the application server s share another symmetric key skgs. Session keys KCG (between C and g) and KCS (between C and s) are derived and distributed during the run. A temporary symmetric key Ktemp is also used to bind the PKINIT exchange to the client’s nonce. A cryptographic hash function hash(·) appears in signatures and authenticators to bind protocol fields together.

The protocol begins with a PKINIT-style authentication of C to ath. In message m1, C sends to ath a request to obtain a ticket-granting key for g. The message
tagKPKI1 . C . g . N1 . aenc{ tagKPKI10 . T0 . N1 . hash(tagKPKI8 . C . g . N1) }sk(C)
contains a tag tagKPKI1 identifying the mechanism, the identities of C and the target realm/server g, and a fresh client nonce N1. It also carries a signed payload, produced by encrypting with C’s private key sk(C), that includes a timestamp T0, the nonce N1, and the hash of the tuple (tagKPKI8, C, g, N1). This signed blob allows ath to verify that the request originates from the holder of sk(C) and is tied to the specific N1 and target g.

In message m2, ath responds to C with material that establishes a shared key KCG between C and g, and a temporary key Ktemp that C can trust as originating from ath. The response
tagKPKI9 . C . senc{ ath . C . g . KCG . T1 }skag . senc{ g . KCG . T1 . N1 }Ktemp . aenc{ tag . aenc{ tagKPKI11 . Ktemp }sk(ath) }pk(C)
contains several components. First, ath sends a ticket for g, senc{ ath . C . g . KCG . T1 }skag, encrypted under skag, which only ath and g know; this binds KCG to C, g, and a lifetime T1. Second, ath sends to C a value senc{ g . KCG . T1 . N1 }Ktemp encrypted under Ktemp, tying the session key KCG and lifetime T1 back to the original nonce N1. Third, ath delivers Ktemp itself to C using public-key protection and a signature: aenc{ tag . aenc{ tagKPKI11 . Ktemp }sk(ath) }pk(C). C decrypts the outer layer with sk(C) to obtain a signed assertion by ath on Ktemp, and thus can trust that Ktemp and the associated encrypted structure were generated by ath in response to m1. After verifying these components, C accepts KCG as its shared key with g, valid for the period T1.

Armed with KCG, C next obtains a service ticket for s from g. In message m3, C contacts g with
s . N2 . senc{ ath . C . g . KCG . T1 }skag . senc{ tagKPKI3 . C . T1 }KCG.
This message identifies the target service s and includes a new client nonce N2. It also presents the ticket from ath (senc{ ath . C . g . KCG . T1 }skag) so g can recover KCG and verify that it is authorized to issue tickets for C, and an authenticator senc{ tagKPKI3 . C . T1 }KCG, encrypted under KCG, which proves that the party presenting the ticket currently knows KCG and binds the run to T1.

In message m4, g responds to C with a service key KCS for communicating with s, together with an associated lifetime T2. The reply
tagKPKI4 . C . senc{ tagKPKI5 . C . s . KCS . T2 }skgs . senc{ tagKPKI2 . s . KCS . T2 . N2 }KCG
contains a ticket for s, senc{ tagKPKI5 . C . s . KCS . T2 }skgs, encrypted under skgs so that only s and g can read it. This ticket binds KCS to C and s with validity T2. The second part, senc{ tagKPKI2 . s . KCS . T2 . N2 }KCG, is for C and is encrypted under KCG; it informs C of KCS, s, and T2, and includes the original nonce N2, thereby assuring C that the response is fresh and linked to m3.

Once C has KCS and the ticket for s, it initiates service authentication with s. In message m5, C sends
senc{ tagKPKI6 . C . s . KCS . T2 }skgs . senc{ tagKPKI7 . C . hash(tagKPKI13 . T2) }KCS.
The first part is the service ticket, encrypted under skgs, which s can decrypt to obtain KCS, C’s identity, and T2. The second part is an authenticator encrypted under KCS that includes C’s identity and the hash of (tagKPKI13, T2). This proves to s that the sender knows KCS and that the run is bound to the lifetime and parameters conveyed in the ticket issued by g.

In message m6, s completes mutual authentication and delivers application data. It sends
senc{ tagKPKI12 . hash(tagKPKI14 . T2) }KCS . senc{ tagKPKI11 . tag . Payload }KCS
back to C. The first encrypted block provides key confirmation and freshness: s returns a hash over (tagKPKI14, T2) under KCS, showing that it has derived the same service key and recognized the same validity interval. The second block carries the application Payload under KCS, tagged and bound to the agreed context tag. Because only C and s know KCS, successful decryption and verification of these structures assure C that Payload originates from s and is protected under the established service key.

The intended security goal is that s non-injectively authenticates to C on Payload, expressed as s *->* C : Payload. That is, whenever C accepts a payload delivered under KCS in this protocol, there is a corresponding run in which s generated that payload while sharing KCS with C. The service key KCS (recorded as the channel key K(C,s)) is used for confidential, integrity-protected communication between C and s after successful completion of the Kerberos_PKINIT exchange.