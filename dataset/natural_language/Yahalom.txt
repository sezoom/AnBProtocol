Yahalom involves three parties—A, B, and a trusted server S—with long-term symmetric keys K(A,S) and K(B,S). A starts by sending B a clear identifier and fresh nonce: (1) A→B: A, Na. B adds its own fresh nonce and asks S for a session key, protecting both nonces under its long-term key: (2) B→S: B, {A, Na, Nb}_{K(B,S)}. S chooses a fresh session key Kab and returns two sealed components: one for A that binds B, Kab, and both nonces under K(A,S), and one for B that binds A and Kab under K(B,S): (3) S→A: {B, Kab, Na, Nb}_{K(A,S)}, {A, Kab}_{K(B,S)}. A forwards B’s component unchanged and proves receipt of Nb by encrypting it under the new session key: (4) A→B: {A, Kab}_{K(B,S)}, {Nb}_{Kab}. Here {X}\_K denotes authenticated encryption of tuple X under key K, Kab is the freshly minted session key, and Na/Nb are nonces contributed by A/B. The flow gives A and B a common Kab (delivered by S and tied to Na,Nb), and the final {Nb}\_{Kab} provides explicit key confirmation back to B.