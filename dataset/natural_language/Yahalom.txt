Protocol Yahalom specifies a symmetric-key server–assisted key establishment and mutual authentication mechanism between two parties A and B, with help from a trusted server S. A shares a long-term symmetric key KAS with S, and B shares a long-term symmetric key KBS with S. These long-term keys are used only to protect communication with S. The server S generates a fresh session key KAB, intended for use as the bidirectional channel key between A and B. Fresh nonces Na and Nb provide replay protection and bind the run to specific contributions from A and B. Symmetric encryption under a key K is written as senc{ … }K.

The protocol proceeds as follows. In message p1, A initiates contact with B by sending A . Na, i.e., its identity together with a newly chosen nonce Na. This message is not encrypted; its main purpose is to let B know that A wants to talk and to provide a freshness contribution from A.

Upon receiving p1, B chooses its own fresh nonce Nb and forwards a request to S in message p2:
B . senc{ A . Na . Nb }KBS.
Here B identifies itself to S with B in the clear, and sends an encrypted block under its long-term key KBS containing A’s identity A, the nonce Na received from A, and B’s own nonce Nb. Because only S and B know KBS, S can decrypt this inner component to learn that B wishes to communicate with A, and can associate the nonces Na and Nb with that request.

In message p3, S generates a fresh session key KAB for A and B, and replies to A with two encrypted parts:
senc{ B . Na . Nb . KAB }KAS . senc{ A . KAB }KBS.
The first part is encrypted under KAS, so only A can decrypt it. It contains the identity B, both nonces Na and Nb, and the new session key KAB. This enables A to verify that the response corresponds to its original Na, includes B’s Nb, and provides KAB as a fresh key for this run. The second part is a “ticket” for B, encrypted under KBS, which binds KAB to A and is readable only by B and S. A cannot decrypt this second component; it will simply forward it.

After decrypting the first part of p3 and accepting KAB, A constructs message p4 to B:
senc{ A . KAB }KBS . senc{ Nb }KAB.
The first component is precisely the ticket from S, senc{ A . KAB }KBS, which A forwards unchanged, allowing B to decrypt it with KBS and learn that S has issued KAB for communication with A. The second component, senc{ Nb }KAB, is encrypted under the new session key and contains B’s nonce Nb. Since only someone who knows KAB can encrypt Nb in this way, this confirms to B that A has received KAB and that both parties now share the same session key.

At the end of the exchange, both A and B have established the fresh key KAB and have evidence that it is associated with the same pair of nonces (Na, Nb) and with the identities A and B. The intended security goals state that A authenticates B and B authenticates A on the triple (KAB, Na, Nb), written as A -> B : KAB . Na . Nb and B -> A : KAB . Na . Nb, and that KAB remains secret between A, B, and S. The session key KAB is then used as the channel key in both directions, represented as K(A,B) and K(B,A), for subsequent secure communication.