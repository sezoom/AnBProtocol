The two-pass protocol mechanism provides unilateral authentication based on digital signatures with an online authority, optimized for low latency and minimal state at the verifier. The verifier starts with a single challenge message carrying a domain-separating tag (tagISO_twopass_symm1) and a fresh nonce RB. The tag disambiguates this protocol (and this exact message role) from any other use of signatures in the system, while RB is the time-variant parameter that delivers replay resistance and ties the response to this specific run.

The claimant’s return flight is deliberately self-contained. It bundles (1) a credential from the authority s, modeled as aenc{ tagISO_twopass_symm2 · A · pk(A) }sk(s), and (2) a claimant signature aenc{ RA · RB · B · Text2 }sk(A). The first item lets the verifier learn and trust the claimant’s public key on the fly—no prior directory lookup—while the second proves possession of the corresponding private key in this run. The tuple covered by the claimant’s signature is chosen to close common gaps: RB gives freshness; B binds the intended peer, eliminating unknown-key-share style misbindings; RA adds claimant-side freshness so the response cannot be precomputed or replayed into a different verifier run; and Text2 is authenticated application data the verifier wishes to rely on. Keeping Text2 inside the signature provides data-origin authentication without assuming transport confidentiality.

A few design choices are intentional trade-offs. There is no mutual authentication in two passes; only the claimant is authenticated to the verifier. There is no key establishment or confidentiality built in; the mechanism is meant to be composed with an AKE (e.g., ephemeral DH) or a protected channel if secrecy or forward secrecy are required. Using an online authority allows short-lived or context-scoped credentials, simplifying revocation, but it makes the run depend on the verifier’s ability to validate s’s signature (including algorithm agility and policy checks).

The tags deserve emphasis. tagISO_twopass_symm1 separates the verifier’s challenge from other challenges in the ecosystem; tagISO_twopass_symm2 separates the authority’s credential from any other signature that s might issue. Although the claimant’s data signature already binds RB and B, consider adding a role-specific tag to that signature too in a profile (“context string” or OID) to harden against cross-protocol and reflection confusion if signatures from different mechanisms might be parsed alike.

Implementation guidance follows from the threat model. Nonces RA and RB should be uniformly random and never reused. The verifier must validate the authority credential before trusting pk(A) (including checking issuer, validity period, and permitted algorithms), then verify the claimant’s signature over the exact, unambiguous serialization of (RA, RB, B, Text2); a transcript hash or fixed field encodings prevent parser ambiguities. All signature operations should be constant-time, and errors should not leak which check failed. Because Text2 is only integrity-protected, not encrypted, applications that need privacy must layer encryption or run this step inside a secure channel.

In short, the protocol is designed to be a lean, two-message “prove-who-you-are now” step: one challenge from the verifier, one credentialed, session-bound signature from the claimant. Everything in the signed tuple is there to bind identity, peer, and freshness to this particular exchange; everything outside is there for ecosystem hygiene and deployability.